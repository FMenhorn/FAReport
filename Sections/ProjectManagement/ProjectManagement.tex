\section{Project Management}
\tododone[inline]{Mohamed}{\textbf{Project Management}}
\tododone[inline]{Benni}{did proofreading}
This section will give an insight into the recommended management strategy to be used for this kind of project and give an overview over the necessary managerial tools suggested for similar projects in the future.
\todointern[inline]{Benni}{move this to challenges and pitfalls section?}
We will also show up the challenges that will probably show up along the way as well as strategies for avoiding pitfalls.

\subsection{Agile Management}
%\textit{Here a brief introduction on agile management will be given with minimal theoretical details (since we always minimze in agile)}
Agile management is a management strategy which is commonly used in software development projects. It is very flexible with respect to developers changing decisions and customers updating their needs. The principle of this management scheme is to divide the full project into smaller chunks, referred to as sprints. Each chunk involves finishing a fully working part of the project. For example, in our project theme, a possible set of sprints could have been:
\begin{enumerate}
  \item{Setting up all interfaces with dummy data to complete the pipeline}
  \item{Replace the dummy data with real data via implementing the necessary models or wrapping the available libararies}
  \item{Adding different levels to the game via image processing and implementing a more complex rigid body representation}
  \item{Allowing the user to draw the levels}
  \item{etc...}
\end{enumerate}
It can be observed that at the end of each sprint the entire code is running, integrated and producing some kind of output (despite its 	plausibility). During each sprint the output keeps developing and iteratively approaches its final shape. In addition the developers do not walk into the trap of being involved in their part while they are hoping that at some distant point in future, they will merge their code with the other teams' and everything will run smoothly. Moreover, this method allows for continuous unit-testing (explained in \autoref{unit_testing}) and early error correction.
One favourable aspect about agile management also is the resulting flexibility in human resources management through relocation and collocation. Relocation is the shuffling of one person's assignment from one team to another after completing the tasks in the respective team or if the team is no more in need of all the manpower. Collocation, on the other hand, is the distribution of one person among more than one team of developers, which is specially encouraged for people handling data interfaces between different teams.

\subsection{Useful Organizational Tools}
In this section, the light will be shed upon the methodology adopted by our group for deciding the project's theme and the concept of scrumming will be exposed. In addition, other facilitation tools will be presented.

\subsubsection{Project's Selection For Dummies}
Project selection is the first step in implementing it. With the flow of ideas and a wide spectrum of imagination among the developers on their first gatherings, they are suddenly confronted with a huge range of project ideas, that for the first glance seem appealing. However, project selection is more than just the vibrance of the idea. The following section will detail some tips on guiding the project selection.

\begin{itemize}
  \item \textbf{Brainstorming}: The first step in choosing a project topic is to set the sky as the limit for people to pour out their ideas all together into one pool, and most importantly, out-loud, allowing people to generate more ideas and develop one another's. An important aspect to be aware of is not to let this stage take a very long time, since time at Ferienakademie is somehow restricted. Also, it is be very helpful to find common grounds between different ideas as soon as possible. For example, "all the proposed ideas will require a Kinect input interface" or "regardless the topic we eventually select, we will need an fluid-structure-interaction framework". Reaching such conclusions early initiates the project in concurrency with finalizing/elaborating the ideas.
  
  \item \textbf{Selection Matrix}: It is very crucial and helpful to decide upon some criteria to evaluate the quality of the idea. On first sight one will assume that all ideas are creative and extravagant -- and it is of course desirable to have such an output -- but their charm might dim after being inspected subjectively with respect to criteria such as:
  \begin{itemize}
    \item \textit{Usability}: How easy can the end-user play this game or use this program? Will he/she need an intensive documentation or a direct supervised training or instructions to start using the game correctly?
    \item \textit{Realizability}: How good is the idea realizable? Can we reach a very simple first state with low effort?
    \item \textit{Extensibility}: How far can we go beyond the first milestone? Can we add more features to the project to make it more challenging and interesting?
    \item \textit{Audience-interest}: How attractive it is for audience to watch the game? For example, chess is a big fail even if you like it!
    \item \textit{Developers-interest}: Are we eager to put all our effort for around 10-days on that project?

  \end{itemize}
For our project, having a matrix (with projects' proposals on one edge and criteria on the other), the developers simply agreed a grade for each criterion for every idea and points we counted.
Automatically, some ideas dropped out and it was obvious towards which idea(s) the decision is heading. In case more than one project got close high ranks, their ideas might be re-discussed and re-evaluated for the final decision. If one cannot come up with a decision a hike often helps.
\end{itemize}


\subsubsection{Scrumming}
%\textit{An idea about scrumming, what are they used for, the sort of updates discussed through them, etc.}
The term scrumming in agile management is inspired by the first move in an American football game, where all the players from each team initially start at the centerline and then in a glance spread all over the field - that move is the \emph{scrum}. The idealisation of such a concept in software development is such that the developers meet frequently (usually weekly or biweekly, at Ferienakademie of course more frequently) to discuss the following three points:
\begin{itemize}
  \item{What has been achieved/completed since the last scrum?}
  \item{What is the prospective task until the next scrum?}
  \item{Have any challenges popped up that require help from other developers?}
\end{itemize}
The main idea of scrumming is to keep all developers and the manger(s) aware of the current status of each separate area in the project and of what each team has achieved so far. 
Scrums are neither for feedback on the project or the developers nor for brainstorming. 
In our case, the scrum was held almost every morning, and if needed, it was rescheduled to a different time during the day, but generally we had a daily scrum. Our team consisted of about 20 developers and having all those in one meeting was thought to be hectic. Hence, for every team, a representative was chosen to attend the scrum and update on behalf of his team. Nevertheless, involving the entire team in the meeting doesn't sound like a bad idea since it could provide an even more detailed insight about the progress of each team (versus the general statement about the progress given by the representative). Additionally this encourages a more direct communication channel between members from different teams dealing with common issues (such as interfaces). \todo{lesson learned? I think this only makes sense after the respective sections.} In our project, I guess, it would have helped to have the developers of the LBM team listen directly in scrums from the RB team and vice versa.

\subsubsection{Code Handling Facilitators}
One of the duties of the project management is to ensure that code is being handled smoothly within the team. Our team has found the following tools pretty beneficial while working on the project.

\begin{itemize}
  \item \textbf{Git}\footnote{An alternative code management tool could be SVN}: for organized code sharing without conflicts, repository updating with current work, experimenting safely with developers' ideas on separate branches, managing conflicts between coders' work, etc. (for managing merge conflicts we suggest \href{meld}{http://meldmerge.org/})
  \item \textbf{CMake}: for a more neat and modular compilation of the whole project from one parent directory
  \item \textbf{Valgrind}: for debugging the code and hunting malicious code lines that result in segmentation faults and other nasty bugs
  \item \textbf{Unit-testing}\footnote{Boost provides a good unit testing tool for C++}: testing each block of code or every interface separately with hardcoded example data to make sure it is bug free and interacting safely with given input and providing sensible output before handling it to the other teams up- and downstream the pipeline\label{unit_testing}
  \item \textbf{Code References}: since we were in an internet-deserted area, having an offline chest of language references and library documentation is worth a fortune. Useful documentations are library's supplier-provided documentation, c++ reference and an offline repository of stackoverflow (and might as well for other libraries used if no PDF documentation was found\todointern{Benni}{what? I don't understand the sentence...})
\end{itemize}

\subsection{Challenges and Obstacles}
\todourgent[inline]{Benni}{Move this part in a final summary chapter? Summary and lessons learned}
Challenges are not bugs, they are features, and one should be indeed aware of their existence and do his/her best to avoid them or at worst be ready to handle them if they can't be detoured \todointern{Benni}{do your best to avoid challenges! Surprising attitude for a BGCE student :P}. Some challenges that we experienced through our project are listed below.

\begin{itemize}
  \item \textbf{Time constraint}: We had many hikes, plus there were a couple of social gatherings and events such as the tournaments and the cultural evening. This boiled down two weeks of work dedicated to the project to much less time. This aspect needs to be taken into account when setting the milestones for the project.
  \item \textbf{Defining the project's topic}: Due to the multi-disciplinary background of the participants as well as various interests, the brainstorming session turns out really vibrant between different ideas. Attention should be drawn to common grounds and the manager(s) should at some point occlude the ongoing flow of ideas to agree onto something.
  \item \textbf{Defining the milestones (be really to \todo{?} agile)}: One of the challenges faced in our projects was phrasing the first milestone deliverables thorough-enough. The first milestone deliverable should not have been just about "Create a game with the simplest fluid-structure interaction and only taking input from Kinect". Such a statement comprised too much of details to work on such as the level of details of rigid bodies capabilities. In addition, it required a comprehensive data handling system between different pipeline stages, which implied that each team should necessarily implement fully-working functionality in order to test the pipeline integrity (imagine how long could this have taken !!).
  A more efficient/agile approach would have been to set the first milestone deliverable to be "building and closing the pipeline with dummy data". This would have crossed out a milestone from the list and given all the teams an insight about into the interaction with the preceding and proceeding pipeline stages.
  \item \textbf{Testing the code}: With around 20 developers, each one implementing a chunk, the code is very vulnerable to get broken by some mathematical fault in a function or a segmentation-fault in one group's code. This could be avoided -- up to some extend -- by unit-testing. Unit-testing is hard-coding an example in order to test the implemented methods and ensure that they are giving the expected response. Although unit-testing requires a considerable additional workload, it, on the other hand, saves the programmers a lot of debugging time in case something goes wrong. This was extremely crucial in the interface between rigid bodies and LBM due to the massive amount of communication between the two codes.
  \item \textbf{Waterfalling}: Waterfall differs from agile management in that it treats the project as a one whole and the tangible output is only delivered at the end. This could be inefficient in projects like ours since waiting till the end since the developers might get demotivated as time passes without tangible output\todo{?}. Also, the project becomes more rigid to adding or modifying milestone deliverables for later stages. The risk of waterfalling is usually high when the first milestone is not clearly bounded and be made aware to the developers. The risk evolves that they end up indulging into coding and extending functionality of their blocks, while delaying integration of their respective parts with the others on the pipeline.
  \item \textbf{Speaking German}: Although the course's official language is English, nevertheless, one can't hold a group of 90\% of Germans to speak their mother language. In such an environment, non-formal meetings between developers (meaning small talks during coffee breaks, discussion over lunch, casual chats, etc.) encourage ideas flow and facilitate problem solving among developers as well as helps management to be updated with deeper details of the project's status. It is rather recommended that the managers' language skills in later courses is good enough to engage and comprehend such situations easily and not just rely on the English scrum meeting for udpates.
\end{itemize}

\todoinintern{}{additional stuff for lessons learned}{ 
\begin{itemize}
\item Managers should not distribute among groups, but manage the team and mistrust everybody. 
\item A group dedicated to game logic (became part of rigid bodies job...) and level design would have been good. 
\item Visu people used OpenGL (very rigid, only runs on some computers, BUT powerful), SDL was the intended language (default in sceleton). Maybe presentation on SDL would have been good? Are there also other possible presentation topics, we missed during ferienakademie?
\end{itemize}
}

